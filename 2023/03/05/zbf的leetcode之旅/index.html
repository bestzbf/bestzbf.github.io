<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>zbf的leetcode之旅 | 小邹的博客</title><meta name="author" content="龟思"><meta name="copyright" content="龟思"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="zbf的leetcode之旅java版 01.Two Sum两数和（简单难度）  解一：两个for12345678910111213public int[] twoSum(int[] nums, int target) &amp;#123;    int []ans&#x3D;new int[2];    for(int i&#x3D;0;i&lt;nums.length;i++)&amp;#123;        for(int">
<meta property="og:type" content="article">
<meta property="og:title" content="zbf的leetcode之旅">
<meta property="og:url" content="http://bestzbf.top/2023/03/05/zbf%E7%9A%84leetcode%E4%B9%8B%E6%97%85/index.html">
<meta property="og:site_name" content="小邹的博客">
<meta property="og:description" content="zbf的leetcode之旅java版 01.Two Sum两数和（简单难度）  解一：两个for12345678910111213public int[] twoSum(int[] nums, int target) &amp;#123;    int []ans&#x3D;new int[2];    for(int i&#x3D;0;i&lt;nums.length;i++)&amp;#123;        for(int">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-03-05T07:35:20.000Z">
<meta property="article:modified_time" content="2023-03-05T08:17:49.435Z">
<meta property="article:author" content="龟思">
<meta property="article:tag" content="我不知道">
<meta name="twitter:card" content="summary"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://bestzbf.top/2023/03/05/zbf%E7%9A%84leetcode%E4%B9%8B%E6%97%85/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'zbf的leetcode之旅',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-05 16:17:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">1</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">小邹的博客</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">zbf的leetcode之旅</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-05T07:35:20.000Z" title="发表于 2023-03-05 15:35:20">2023-03-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-05T08:17:49.435Z" title="更新于 2023-03-05 16:17:49">2023-03-05</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="zbf的leetcode之旅"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="zbf的leetcode之旅"><a href="#zbf的leetcode之旅" class="headerlink" title="zbf的leetcode之旅"></a>zbf的leetcode之旅</h1><p>java版</p>
<h2 id="01-Two-Sum"><a href="#01-Two-Sum" class="headerlink" title="01.Two Sum"></a>01.Two Sum</h2><p>两数和（简单难度）</p>
<p><img src="https://zbfblogs.oss-cn-hangzhou.aliyuncs.com/blogs/image-20221023172339317-1667721192037.png" alt="image-20221023172339317"></p>
<h3 id="解一：两个for"><a href="#解一：两个for" class="headerlink" title="解一：两个for"></a>解一：两个for</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span> []ans=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=(i+<span class="number">1</span>);j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]+nums[j]==target)&#123;</span><br><span class="line">                ans[<span class="number">0</span>]=i;</span><br><span class="line">                ans[<span class="number">1</span>]=j;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：两层 for 循环，O（n²）</p>
<p>空间复杂度：O（1）</p>
<h3 id="解二：for-HashMap"><a href="#解二：for-HashMap" class="headerlink" title="解二：for+HashMap"></a>解二：for+HashMap</h3><h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><p>这个函数可以简单描述为：<strong>存储位置 &#x3D; f(关键字)</strong> ，这个函数f一般称为哈希函数，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作：。</p>
<p><img src="https://zbfblogs.oss-cn-hangzhou.aliyuncs.com/blogs/2018110221063296.png" alt="哈希表数据插入过程"></p>
<p>查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可</p>
<p><strong>哈希冲突</strong></p>
<p>  然而万事无完美，<strong>如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办</strong>？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的<strong>哈希冲突</strong>，也叫<strong>哈希碰撞</strong>。<br>  前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 计算简单和散列地址分布均匀,但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了<strong>链地址法</strong>，也就是<strong>数组+链表</strong>的方式。</p>
<p>HashMap的实现原理</p>
<p>HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。（其实所谓Map其实就是保存了两个对象之间的映射关系的一种集合）<br>所以，HashMap的总体结构如下：<br><img src="https://zbfblogs.oss-cn-hangzhou.aliyuncs.com/blogs/20181102221702492.png" alt="在这里插入图片描述"><br>简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的.<br>如果定位到的数组位置不含链表（当前entry的next指向null）,那么查找，添加等操作很快，仅需一次寻址即可；<br>如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；<br>对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。<br>所以，性能考虑，HashMap中的链表出现越少，性能才会越好</p>
<p>在上边的解法中看下第⼆个 for 循环步骤。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=(i+<span class="number">1</span>);j&lt;nums.length;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[i]+nums[j]==target)&#123;</span><br></pre></td></tr></table></figure>

<p>换个理解⽅式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=(i+<span class="number">1</span>);j&lt;nums.length;j++)&#123; </span><br><span class="line">    sub=target-nums[i]</span><br><span class="line">     <span class="keyword">if</span>(nums[j]==sub)&#123;</span><br></pre></td></tr></table></figure>

<p>第⼆层 for 循环⽆⾮是遍历所有的元素，看哪个元素等于 sub ，时间复杂度为 O（n）。<br>我们可以把数组的每个元素保存为 hash 的 key，下标保存为 hash 的 value 。<br>这样只需判断 sub 在不在 hash 的 key ⾥就可以了，⽽此时的时间复杂度仅为 O（1）！<br>需要注意的地⽅是，还需判断找到的元素不是当前元素，因为题⽬⾥讲⼀个元素只能⽤⼀次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        map.put(nums[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="type">int</span> sub=target-nums[i];</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(sub)&amp;&amp;map.get(sub)!=i)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,map.get(sub)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;No two sum solution&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="解三：解二写法的改进"><a href="#解三：解二写法的改进" class="headerlink" title="解三：解二写法的改进"></a>解三：解二写法的改进</h3><p>看解法⼆中，两个 for 循环，他们⻓的⼀样，我们当然可以把它合起来。复杂度上不会带来什么变化，<br>变化的仅仅是不需要判断是不是当前元素了，因为当前元素还没有添加进 hash ⾥。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="type">int</span> sub=target-nums[i];</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(sub))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,map.get(sub)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;No two sum solution&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>暴力的方法可以解决。闪亮的点就是，时间复杂度从 O（n²）降为 O（n） 的时候，对 hash 的应用，可以深刻理解HashMap</p>
<h2 id="02-Add-Two-Numbers"><a href="#02-Add-Two-Numbers" class="headerlink" title="02.Add Two Numbers"></a>02.Add Two Numbers</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>就是两个链表表示的数相加，这样就可以实现两个很大的数相加了，无需考虑数值 int ，float 的限制了。</p>
<p><img src="https://zbfblogs.oss-cn-hangzhou.aliyuncs.com/blogs/TIM%E6%88%AA%E5%9B%BE20180714105005.jpg" alt="img"></p>
<h3 id="解一："><a href="#解一：" class="headerlink" title="解一："></a>解一：</h3><p>首先每一位相加肯定会产生进位，我们用 carry 表示，进位最大会是 1，下边是伪代码。</p>
<ul>
<li>初始化一个节点的头，dummy head ，但是这个头不存储数字。并且将 curr 指向它。</li>
<li>初始化进位 carry 为 0 。</li>
<li>初始化 p 和 q 分别为给定的两个链表 l1 和 l2 的头，也就是个位。</li>
<li>循环，直到 l1 和 l2 全部到达 null 。<ul>
<li>设置 x 为 p 节点的值，如果 p 已经到达了 null，设置 x 为 0 。</li>
<li>设置 y 为 q 节点的值，如果 q 已经到达了 null，设置 y 为 0 。</li>
<li>设置 sum &#x3D; x + y + carry 。</li>
<li>更新 carry &#x3D; sum &#x2F; 10 。</li>
<li>创建一个值为 sum mod 10 的节点，并将 curr 的 next 指向它，同时 curr 指向变为当前的新节点。</li>
<li>向前移动 p 和 q 。</li>
</ul>
</li>
<li>判断 carry 是否等于 1 ，如果等于 1 ，在链表末尾增加一个为 1 的节点。</li>
<li>返回 dummy head 的 next ，也就是个位数开始的地方。</li>
</ul>
<p>初始化的节点 dummy head 没有存储值，最后返回 dummy head 的 next 。这样的好处是不用单独对 head 进行判断改变值。也就是如果一开始的 head 就是代表个位数，那么开始初始化的时候并不知道它的值是多少，所以还需要在进入循环前单独对它进行值的更正，不能像现在一样只用一个循环简洁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line">    ListNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummyHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> l1, q = l2, curr = dummyHead;</span><br><span class="line">    <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span> || q != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (p != <span class="literal">null</span>) ? p.val : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (q != <span class="literal">null</span>) ? q.val : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> carry + x + y;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        curr.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">        curr = curr.next;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span>) p = p.next;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="literal">null</span>) q = q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        curr.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O（max（m，n）），m 和 n 代表 l1 和 l2 的长度。</p>
<p>空间复杂度：O（max（m，n）），m 和 n 代表 l1 和 l2 的长度。而其实新的 List 最大长度是 O（max（m，n））+ 1，因为我们的 head 没有存储值。</p>
<h3 id="拓展：逆序"><a href="#拓展：逆序" class="headerlink" title="拓展：逆序"></a>拓展：逆序</h3><img src="https://zbfblogs.oss-cn-hangzhou.aliyuncs.com/blogs/2_add.jpg" alt="img" style="zoom:150%;" />

<p>如果链表存储的顺序反过来怎么办？</p>
<h4 id="1-迭代："><a href="#1-迭代：" class="headerlink" title="1.迭代："></a>1.迭代：</h4><p>看的迷迷糊糊的，不是很懂</p>
<p>首先看一下原链表。</p>
<p><img src="https://zbfblogs.oss-cn-hangzhou.aliyuncs.com/blogs/l0.jpg" alt="img"></p>
<p>总共需要添加两个指针，pre 和 next。</p>
<p>初始化 pre 指向 NULL 。</p>
<p><img src="https://zbfblogs.oss-cn-hangzhou.aliyuncs.com/blogs/l00.jpg" alt="img"></p>
<p>然后就是迭代的步骤，总共四步，顺序一步都不能错。</p>
<ul>
<li><p>next 指向 head 的 next ，防止原链表丢失</p>
<p><img src="https://zbfblogs.oss-cn-hangzhou.aliyuncs.com/blogs/l1.jpg" alt="img"></p>
</li>
<li><p>head 的 next 从原来链表脱离，指向 pre 。</p>
<p><img src="https://zbfblogs.oss-cn-hangzhou.aliyuncs.com/blogs/l2.jpg" alt="img"></p>
</li>
<li><p>pre 指向 head</p>
<p><img src="https://zbfblogs.oss-cn-hangzhou.aliyuncs.com/blogs/l3.jpg" alt="img"></p>
</li>
<li><p>head 指向 next</p>
<p><img src="https://zbfblogs.oss-cn-hangzhou.aliyuncs.com/blogs/l4.jpg" alt="img"></p>
</li>
</ul>
<p>一次迭代就完成了，如果再进行一次迭代就变成下边的样子。</p>
<p><img src="https://zbfblogs.oss-cn-hangzhou.aliyuncs.com/blogs/l5.jpg" alt="img"></p>
<p>可以看到整个过程无非是把旧链表的 head 取下来，添加的新的链表上。代码怎么写呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">next = head -&gt; next; <span class="comment">//保存 head 的 next , 以防取下 head 后丢失</span></span><br><span class="line">head -&gt; next = pre; <span class="comment">//将 head 从原链表取下来，添加到新链表上</span></span><br><span class="line">pre = head;<span class="comment">// pre 右移</span></span><br><span class="line">head = next; <span class="comment">// head 右移</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来就是停止条件了，我们再进行一次循环。</p>
<p><img src="https://zbfblogs.oss-cn-hangzhou.aliyuncs.com/blogs/l6.jpg" alt="img"></p>
<p>可以发现当 head 或者 next 指向 null 的时候，我们就可以停止了。此时将 pre 返回，便是逆序了的链表了。</p>
<h4 id="2-递归思想："><a href="#2-递归思想：" class="headerlink" title="2.递归思想："></a>2.递归思想：</h4><p>看不懂www，以后再回来填坑</p>
<ul>
<li><p>首先假设我们实现了将单链表逆序的函数，ListNode reverseListRecursion(ListNode head) ，传入链表头，返回逆序后的链表头。</p>
</li>
<li><p>接着我们确定如何把问题一步一步的化小，我们可以这样想。</p>
<p>把 head 结点拿出来，剩下的部分我们调用函数 reverseListRecursion ，这样剩下的部分就逆序了，接着我们把 head 结点放到新链表的尾部就可以了。这就是整个递归的思想了。</p>
<p><img src="https://zbfblogs.oss-cn-hangzhou.aliyuncs.com/blogs/ll0.jpg" alt="img"></p>
<ul>
<li><p>head 结点拿出来</p>
<p><img src="https://zbfblogs.oss-cn-hangzhou.aliyuncs.com/blogs/ll1.jpg" alt="img"></p>
</li>
<li><p>剩余部分调用逆序函数 reverseListRecursion ，并得到了 newhead</p>
<p><img src="https://zbfblogs.oss-cn-hangzhou.aliyuncs.com/blogs/ll2.jpg" alt="img"></p>
</li>
<li><p>将 2 指向 1 ，1 指向 null，将 newhead 返回即可。</p>
<p><img src="https://zbfblogs.oss-cn-hangzhou.aliyuncs.com/blogs/ll3.jpg" alt="img"></p>
</li>
</ul>
</li>
<li><p>找到递归出口</p>
<p>当然就是如果结点的个数是一个，那么逆序的话还是它本身，直接 return 就够了。怎么判断结点个数是不是一个呢？它的 next 等于 null 就说明是一个了。但如果传进来的本身就是 null，那么直接找它的 next 会报错，所以先判断传进来的是不是 null ，如果是，也是直接返回就可以了。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseListRecursion</span><span class="params">(ListNode head)</span>&#123; </span><br><span class="line">        ListNode newHead;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>||head.next==<span class="literal">null</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        newHead=reverseListRecursion(head.next); <span class="comment">//head.next 作为剩余部分的头指针</span></span><br><span class="line">        head.next.next=head; <span class="comment">//head.next 代表新链表的尾，将它的 next 置为 head，就是将 head 加到最后了。</span></span><br><span class="line">        head.next=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>











































</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://bestzbf.top">龟思</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://bestzbf.top/2023/03/05/zbf%E7%9A%84leetcode%E4%B9%8B%E6%97%85/">http://bestzbf.top/2023/03/05/zbf%E7%9A%84leetcode%E4%B9%8B%E6%97%85/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://bestzbf.top" target="_blank">小邹的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">龟思</div><div class="author-info__description">笔记和日常</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">1</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#zbf%E7%9A%84leetcode%E4%B9%8B%E6%97%85"><span class="toc-number">1.</span> <span class="toc-text">zbf的leetcode之旅</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-Two-Sum"><span class="toc-number">1.1.</span> <span class="toc-text">01.Two Sum</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E4%B8%80%EF%BC%9A%E4%B8%A4%E4%B8%AAfor"><span class="toc-number">1.1.1.</span> <span class="toc-text">解一：两个for</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E4%BA%8C%EF%BC%9Afor-HashMap"><span class="toc-number">1.1.2.</span> <span class="toc-text">解二：for+HashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#HashMap"><span class="toc-number">1.1.2.0.1.</span> <span class="toc-text">HashMap</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E4%B8%89%EF%BC%9A%E8%A7%A3%E4%BA%8C%E5%86%99%E6%B3%95%E7%9A%84%E6%94%B9%E8%BF%9B"><span class="toc-number">1.1.3.</span> <span class="toc-text">解三：解二写法的改进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-Add-Two-Numbers"><span class="toc-number">1.2.</span> <span class="toc-text">02.Add Two Numbers</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-number">1.2.1.</span> <span class="toc-text">题目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E4%B8%80%EF%BC%9A"><span class="toc-number">1.2.2.</span> <span class="toc-text">解一：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%EF%BC%9A%E9%80%86%E5%BA%8F"><span class="toc-number">1.2.3.</span> <span class="toc-text">拓展：逆序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%BF%AD%E4%BB%A3%EF%BC%9A"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">1.迭代：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%80%92%E5%BD%92%E6%80%9D%E6%83%B3%EF%BC%9A"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2.递归思想：</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/05/zbf%E7%9A%84leetcode%E4%B9%8B%E6%97%85/" title="zbf的leetcode之旅"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="zbf的leetcode之旅"/></a><div class="content"><a class="title" href="/2023/03/05/zbf%E7%9A%84leetcode%E4%B9%8B%E6%97%85/" title="zbf的leetcode之旅">zbf的leetcode之旅</a><time datetime="2023-03-05T07:35:20.000Z" title="发表于 2023-03-05 15:35:20">2023-03-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 龟思</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>